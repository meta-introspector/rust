use std::env;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

fn main() {
    let current_dir = env::current_dir().unwrap();
    println!("build.rs current working directory: {:?}", current_dir);
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_clap_providers.rs");
    let mut f = File::create(&dest_path).unwrap();

    f.write_all(b"// This file is generated by build.rs\n").unwrap();
    f.write_all(b"// It contains the generated CLAP argument and subcommand providers.\n\n").unwrap();
    f.write_all(b"use clap::Command;\n").unwrap();
    f.write_all(b"use crate::cargo_integration::clap_extensibility::{ArgumentProvider, SubcommandProvider};\n\n").unwrap();

    f.write_all(b"pub fn get_argument_providers() -> Vec<Box<dyn ArgumentProvider>> {\n").unwrap();
    f.write_all(b"    vec![\n").unwrap();
    generate_providers_list(&mut f, "src/cargo_integration/global_args", "ArgumentProvider");
    f.write_all(b"    ]\n").unwrap();
    f.write_all(b"}

").unwrap();

    f.write_all(b"pub fn get_subcommand_providers() -> Vec<Box<dyn SubcommandProvider>> {\n").unwrap();
    f.write_all(b"    vec![\n").unwrap();
    generate_providers_list(&mut f, "src/cargo_integration/subcommands", "SubcommandProvider");
    f.write_all(b"    ]\n").unwrap();
    f.write_all(b"}
").unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=crates/rust-bootstrap/src/cargo_integration/global_args");
    println!("cargo:rerun-if-changed=crates/rust-bootstrap/src/cargo_integration/subcommands");
}

fn generate_providers_list(file: &mut File, scan_dir: &str, provider_type: &str) {
    let scan_path = Path::new(scan_dir);
    for entry in fs::read_dir(scan_path).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_file() {
            if let Some(file_name) = path.file_stem() {
                let module_name = file_name.to_str().unwrap();
                if module_name != "mod" {
                    let provider_name = format!("{}Provider", pascal_case(module_name));
                    writeln!(file, "        Box::new(crate::cargo_integration::{}::{}::{}),",
                             if provider_type == "ArgumentProvider" { "global_args" } else { "subcommands" },
                             module_name,
                             provider_name
                    ).unwrap();
                }
            }
        }
    }
}

// Helper function to convert snake_case to PascalCase
fn pascal_case(s: &str) -> String {
    s.split('_')
        .map(|s| {
            let mut c = s.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect()
}
